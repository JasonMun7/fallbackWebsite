{"version":3,"file":"bidi-js-b480259a.js","sources":["../../node_modules/bidi-js/dist/bidi.mjs"],"sourcesContent":["function bidiFactory() {\nvar bidi = (function (exports) {\n\n  // Bidi character types data, auto generated\n  var DATA = {\n    \"R\": \"13k,1a,2,3,3,2+1j,ch+16,a+1,5+2,2+n,5,a,4,6+16,4+3,h+1b,4mo,179q,2+9,2+11,2i9+7y,2+68,4,3+4,5+13,4+3,2+4k,3+29,8+cf,1t+7z,w+17,3+3m,1t+3z,16o1+5r,8+30,8+mc,29+1r,29+4v,75+73\",\n    \"EN\": \"1c+9,3d+1,6,187+9,513,4+5,7+9,sf+j,175h+9,qw+q,161f+1d,4xt+a,25i+9\",\n    \"ES\": \"17,2,6dp+1,f+1,av,16vr,mx+1,4o,2\",\n    \"ET\": \"z+2,3h+3,b+1,ym,3e+1,2o,p4+1,8,6u,7c,g6,1wc,1n9+4,30+1b,2n,6d,qhx+1,h0m,a+1,49+2,63+1,4+1,6bb+3,12jj\",\n    \"AN\": \"16o+5,2j+9,2+1,35,ed,1ff2+9,87+u\",\n    \"CS\": \"18,2+1,b,2u,12k,55v,l,17v0,2,3,53,2+1,b\",\n    \"B\": \"a,3,f+2,2v,690\",\n    \"S\": \"9,2,k\",\n    \"WS\": \"c,k,4f4,1vk+a,u,1j,335\",\n    \"ON\": \"x+1,4+4,h+5,r+5,r+3,z,5+3,2+1,2+1,5,2+2,3+4,o,w,ci+1,8+d,3+d,6+8,2+g,39+1,9,6+1,2,33,b8,3+1,3c+1,7+1,5r,b,7h+3,sa+5,2,3i+6,jg+3,ur+9,2v,ij+1,9g+9,7+a,8m,4+1,49+x,14u,2+2,c+2,e+2,e+2,e+1,i+n,e+e,2+p,u+2,e+2,36+1,2+3,2+1,b,2+2,6+5,2,2,2,h+1,5+4,6+3,3+f,16+2,5+3l,3+81,1y+p,2+40,q+a,m+13,2r+ch,2+9e,75+hf,3+v,2+2w,6e+5,f+6,75+2a,1a+p,2+2g,d+5x,r+b,6+3,4+o,g,6+1,6+2,2k+1,4,2j,5h+z,1m+1,1e+f,t+2,1f+e,d+3,4o+3,2s+1,w,535+1r,h3l+1i,93+2,2s,b+1,3l+x,2v,4g+3,21+3,kz+1,g5v+1,5a,j+9,n+v,2,3,2+8,2+1,3+2,2,3,46+1,4+4,h+5,r+5,r+a,3h+2,4+6,b+4,78,1r+24,4+c,4,1hb,ey+6,103+j,16j+c,1ux+7,5+g,fsh,jdq+1t,4,57+2e,p1,1m,1m,1m,1m,4kt+1,7j+17,5+2r,d+e,3+e,2+e,2+10,m+4,w,1n+5,1q,4z+5,4b+rb,9+c,4+c,4+37,d+2g,8+b,l+b,5+1j,9+9,7+13,9+t,3+1,27+3c,2+29,2+3q,d+d,3+4,4+2,6+6,a+o,8+6,a+2,e+6,16+42,2+1i\",\n    \"BN\": \"0+8,6+d,2s+5,2+p,e,4m9,1kt+2,2b+5,5+5,17q9+v,7k,6p+8,6+1,119d+3,440+7,96s+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+75,6p+2rz,1ben+1,1ekf+1,1ekf+1\",\n    \"NSM\": \"lc+33,7o+6,7c+18,2,2+1,2+1,2,21+a,1d+k,h,2u+6,3+5,3+1,2+3,10,v+q,2k+a,1n+8,a,p+3,2+8,2+2,2+4,18+2,3c+e,2+v,1k,2,5+7,5,4+6,b+1,u,1n,5+3,9,l+1,r,3+1,1m,5+1,5+1,3+2,4,v+1,4,c+1,1m,5+4,2+1,5,l+1,n+5,2,1n,3,2+3,9,8+1,c+1,v,1q,d,1f,4,1m+2,6+2,2+3,8+1,c+1,u,1n,g+1,l+1,t+1,1m+1,5+3,9,l+1,u,21,8+2,2,2j,3+6,d+7,2r,3+8,c+5,23+1,s,2,2,1k+d,2+4,2+1,6+a,2+z,a,2v+3,2+5,2+1,3+1,q+1,5+2,h+3,e,3+1,7,g,jk+2,qb+2,u+2,u+1,v+1,1t+1,2+6,9,3+a,a,1a+2,3c+1,z,3b+2,5+1,a,7+2,64+1,3,1n,2+6,2,2,3+7,7+9,3,1d+g,1s+3,1d,2+4,2,6,15+8,d+1,x+3,3+1,2+2,1l,2+1,4,2+2,1n+7,3+1,49+2,2+c,2+6,5,7,4+1,5j+1l,2+4,k1+w,2db+2,3y,2p+v,ff+3,30+1,n9x+3,2+9,x+1,29+1,7l,4,5,q+1,6,48+1,r+h,e,13+7,q+a,1b+2,1d,3+3,3+1,14,1w+5,3+1,3+1,d,9,1c,1g,2+2,3+1,6+1,2,17+1,9,6n,3,5,fn5,ki+f,h+f,r2,6b,46+4,1af+2,2+1,6+3,15+2,5,4m+1,fy+3,as+1,4a+a,4x,1j+e,1l+2,1e+3,3+1,1y+2,11+4,2+7,1r,d+1,1h+8,b+3,3,2o+2,3,2+1,7,4h,4+7,m+1,1m+1,4,12+6,4+4,5g+7,3+2,2,o,2d+5,2,5+1,2+1,6n+3,7+1,2+1,s+1,2e+7,3,2+1,2z,2,3+5,2,2u+2,3+3,2+4,78+8,2+1,75+1,2,5,41+3,3+1,5,x+5,3+1,15+5,3+3,9,a+5,3+2,1b+c,2+1,bb+6,2+5,2d+l,3+6,2+1,2+1,3f+5,4,2+1,2+6,2,21+1,4,2,9o+1,f0c+4,1o+6,t5,1s+3,2a,f5l+1,43t+2,i+7,3+6,v+3,45+2,1j0+1i,5+1d,9,f,n+4,2+e,11t+6,2+g,3+6,2+1,2+4,7a+6,c6+3,15t+6,32+6,gzhy+6n\",\n    \"AL\": \"16w,3,2,e+1b,z+2,2+2s,g+1,8+1,b+m,2+t,s+2i,c+e,4h+f,1d+1e,1bwe+dp,3+3z,x+c,2+1,35+3y,2rm+z,5+7,b+5,dt+l,c+u,17nl+27,1t+27,4x+6n,3+d\",\n    \"LRO\": \"6ct\",\n    \"RLO\": \"6cu\",\n    \"LRE\": \"6cq\",\n    \"RLE\": \"6cr\",\n    \"PDF\": \"6cs\",\n    \"LRI\": \"6ee\",\n    \"RLI\": \"6ef\",\n    \"FSI\": \"6eg\",\n    \"PDI\": \"6eh\"\n  };\n\n  var TYPES = {};\n  var TYPES_TO_NAMES = {};\n  TYPES.L = 1; //L is the default\n  TYPES_TO_NAMES[1] = 'L';\n  Object.keys(DATA).forEach(function (type, i) {\n    TYPES[type] = 1 << (i + 1);\n    TYPES_TO_NAMES[TYPES[type]] = type;\n  });\n  Object.freeze(TYPES);\n\n  var ISOLATE_INIT_TYPES = TYPES.LRI | TYPES.RLI | TYPES.FSI;\n  var STRONG_TYPES = TYPES.L | TYPES.R | TYPES.AL;\n  var NEUTRAL_ISOLATE_TYPES = TYPES.B | TYPES.S | TYPES.WS | TYPES.ON | TYPES.FSI | TYPES.LRI | TYPES.RLI | TYPES.PDI;\n  var BN_LIKE_TYPES = TYPES.BN | TYPES.RLE | TYPES.LRE | TYPES.RLO | TYPES.LRO | TYPES.PDF;\n  var TRAILING_TYPES = TYPES.S | TYPES.WS | TYPES.B | ISOLATE_INIT_TYPES | TYPES.PDI | BN_LIKE_TYPES;\n\n  var map = null;\n\n  function parseData () {\n    if (!map) {\n      //const start = performance.now()\n      map = new Map();\n      var loop = function ( type ) {\n        if (DATA.hasOwnProperty(type)) {\n          var lastCode = 0;\n          DATA[type].split(',').forEach(function (range) {\n            var ref = range.split('+');\n            var skip = ref[0];\n            var step = ref[1];\n            skip = parseInt(skip, 36);\n            step = step ? parseInt(step, 36) : 0;\n            map.set(lastCode += skip, TYPES[type]);\n            for (var i = 0; i < step; i++) {\n              map.set(++lastCode, TYPES[type]);\n            }\n          });\n        }\n      };\n\n      for (var type in DATA) loop( type );\n      //console.log(`char types parsed in ${performance.now() - start}ms`)\n    }\n  }\n\n  /**\n   * @param {string} char\n   * @return {number}\n   */\n  function getBidiCharType (char) {\n    parseData();\n    return map.get(char.codePointAt(0)) || TYPES.L\n  }\n\n  function getBidiCharTypeName(char) {\n    return TYPES_TO_NAMES[getBidiCharType(char)]\n  }\n\n  // Bidi bracket pairs data, auto generated\n  var data$1 = {\n    \"pairs\": \"14>1,1e>2,u>2,2wt>1,1>1,1ge>1,1wp>1,1j>1,f>1,hm>1,1>1,u>1,u6>1,1>1,+5,28>1,w>1,1>1,+3,b8>1,1>1,+3,1>3,-1>-1,3>1,1>1,+2,1s>1,1>1,x>1,th>1,1>1,+2,db>1,1>1,+3,3>1,1>1,+2,14qm>1,1>1,+1,4q>1,1e>2,u>2,2>1,+1\",\n    \"canonical\": \"6f1>-6dx,6dy>-6dx,6ec>-6ed,6ee>-6ed,6ww>2jj,-2ji>2jj,14r4>-1e7l,1e7m>-1e7l,1e7m>-1e5c,1e5d>-1e5b,1e5c>-14qx,14qy>-14qx,14vn>-1ecg,1ech>-1ecg,1edu>-1ecg,1eci>-1ecg,1eda>-1ecg,1eci>-1ecg,1eci>-168q,168r>-168q,168s>-14ye,14yf>-14ye\"\n  };\n\n  /**\n   * Parses an string that holds encoded codepoint mappings, e.g. for bracket pairs or\n   * mirroring characters, as encoded by scripts/generateBidiData.js. Returns an object\n   * holding the `map`, and optionally a `reverseMap` if `includeReverse:true`.\n   * @param {string} encodedString\n   * @param {boolean} includeReverse - true if you want reverseMap in the output\n   * @return {{map: Map<number, number>, reverseMap?: Map<number, number>}}\n   */\n  function parseCharacterMap (encodedString, includeReverse) {\n    var radix = 36;\n    var lastCode = 0;\n    var map = new Map();\n    var reverseMap = includeReverse && new Map();\n    var prevPair;\n    encodedString.split(',').forEach(function visit(entry) {\n      if (entry.indexOf('+') !== -1) {\n        for (var i = +entry; i--;) {\n          visit(prevPair);\n        }\n      } else {\n        prevPair = entry;\n        var ref = entry.split('>');\n        var a = ref[0];\n        var b = ref[1];\n        a = String.fromCodePoint(lastCode += parseInt(a, radix));\n        b = String.fromCodePoint(lastCode += parseInt(b, radix));\n        map.set(a, b);\n        includeReverse && reverseMap.set(b, a);\n      }\n    });\n    return { map: map, reverseMap: reverseMap }\n  }\n\n  var openToClose, closeToOpen, canonical;\n\n  function parse$1 () {\n    if (!openToClose) {\n      //const start = performance.now()\n      var ref = parseCharacterMap(data$1.pairs, true);\n      var map = ref.map;\n      var reverseMap = ref.reverseMap;\n      openToClose = map;\n      closeToOpen = reverseMap;\n      canonical = parseCharacterMap(data$1.canonical, false).map;\n      //console.log(`brackets parsed in ${performance.now() - start}ms`)\n    }\n  }\n\n  function openingToClosingBracket (char) {\n    parse$1();\n    return openToClose.get(char) || null\n  }\n\n  function closingToOpeningBracket (char) {\n    parse$1();\n    return closeToOpen.get(char) || null\n  }\n\n  function getCanonicalBracket (char) {\n    parse$1();\n    return canonical.get(char) || null\n  }\n\n  // Local type aliases\n  var TYPE_L = TYPES.L;\n  var TYPE_R = TYPES.R;\n  var TYPE_EN = TYPES.EN;\n  var TYPE_ES = TYPES.ES;\n  var TYPE_ET = TYPES.ET;\n  var TYPE_AN = TYPES.AN;\n  var TYPE_CS = TYPES.CS;\n  var TYPE_B = TYPES.B;\n  var TYPE_S = TYPES.S;\n  var TYPE_ON = TYPES.ON;\n  var TYPE_BN = TYPES.BN;\n  var TYPE_NSM = TYPES.NSM;\n  var TYPE_AL = TYPES.AL;\n  var TYPE_LRO = TYPES.LRO;\n  var TYPE_RLO = TYPES.RLO;\n  var TYPE_LRE = TYPES.LRE;\n  var TYPE_RLE = TYPES.RLE;\n  var TYPE_PDF = TYPES.PDF;\n  var TYPE_LRI = TYPES.LRI;\n  var TYPE_RLI = TYPES.RLI;\n  var TYPE_FSI = TYPES.FSI;\n  var TYPE_PDI = TYPES.PDI;\n\n  /**\n   * @typedef {object} GetEmbeddingLevelsResult\n   * @property {{start, end, level}[]} paragraphs\n   * @property {Uint8Array} levels\n   */\n\n  /**\n   * This function applies the Bidirectional Algorithm to a string, returning the resolved embedding levels\n   * in a single Uint8Array plus a list of objects holding each paragraph's start and end indices and resolved\n   * base embedding level.\n   *\n   * @param {string} string - The input string\n   * @param {\"ltr\"|\"rtl\"|\"auto\"} [baseDirection] - Use \"ltr\" or \"rtl\" to force a base paragraph direction,\n   *        otherwise a direction will be chosen automatically from each paragraph's contents.\n   * @return {GetEmbeddingLevelsResult}\n   */\n  function getEmbeddingLevels (string, baseDirection) {\n    var MAX_DEPTH = 125;\n\n    // Start by mapping all characters to their unicode type, as a bitmask integer\n    var charTypes = new Uint32Array(string.length);\n    for (var i = 0; i < string.length; i++) {\n      charTypes[i] = getBidiCharType(string[i]);\n    }\n\n    var charTypeCounts = new Map(); //will be cleared at start of each paragraph\n    function changeCharType(i, type) {\n      var oldType = charTypes[i];\n      charTypes[i] = type;\n      charTypeCounts.set(oldType, charTypeCounts.get(oldType) - 1);\n      if (oldType & NEUTRAL_ISOLATE_TYPES) {\n        charTypeCounts.set(NEUTRAL_ISOLATE_TYPES, charTypeCounts.get(NEUTRAL_ISOLATE_TYPES) - 1);\n      }\n      charTypeCounts.set(type, (charTypeCounts.get(type) || 0) + 1);\n      if (type & NEUTRAL_ISOLATE_TYPES) {\n        charTypeCounts.set(NEUTRAL_ISOLATE_TYPES, (charTypeCounts.get(NEUTRAL_ISOLATE_TYPES) || 0) + 1);\n      }\n    }\n\n    var embedLevels = new Uint8Array(string.length);\n    var isolationPairs = new Map(); //init->pdi and pdi->init\n\n    // === 3.3.1 The Paragraph Level ===\n    // 3.3.1 P1: Split the text into paragraphs\n    var paragraphs = []; // [{start, end, level}, ...]\n    var paragraph = null;\n    for (var i$1 = 0; i$1 < string.length; i$1++) {\n      if (!paragraph) {\n        paragraphs.push(paragraph = {\n          start: i$1,\n          end: string.length - 1,\n          // 3.3.1 P2-P3: Determine the paragraph level\n          level: baseDirection === 'rtl' ? 1 : baseDirection === 'ltr' ? 0 : determineAutoEmbedLevel(i$1, false)\n        });\n      }\n      if (charTypes[i$1] & TYPE_B) {\n        paragraph.end = i$1;\n        paragraph = null;\n      }\n    }\n\n    var FORMATTING_TYPES = TYPE_RLE | TYPE_LRE | TYPE_RLO | TYPE_LRO | ISOLATE_INIT_TYPES | TYPE_PDI | TYPE_PDF | TYPE_B;\n    var nextEven = function (n) { return n + ((n & 1) ? 1 : 2); };\n    var nextOdd = function (n) { return n + ((n & 1) ? 2 : 1); };\n\n    // Everything from here on will operate per paragraph.\n    for (var paraIdx = 0; paraIdx < paragraphs.length; paraIdx++) {\n      paragraph = paragraphs[paraIdx];\n      var statusStack = [{\n        _level: paragraph.level,\n        _override: 0, //0=neutral, 1=L, 2=R\n        _isolate: 0 //bool\n      }];\n      var stackTop = (void 0);\n      var overflowIsolateCount = 0;\n      var overflowEmbeddingCount = 0;\n      var validIsolateCount = 0;\n      charTypeCounts.clear();\n\n      // === 3.3.2 Explicit Levels and Directions ===\n      for (var i$2 = paragraph.start; i$2 <= paragraph.end; i$2++) {\n        var charType = charTypes[i$2];\n        stackTop = statusStack[statusStack.length - 1];\n\n        // Set initial counts\n        charTypeCounts.set(charType, (charTypeCounts.get(charType) || 0) + 1);\n        if (charType & NEUTRAL_ISOLATE_TYPES) {\n          charTypeCounts.set(NEUTRAL_ISOLATE_TYPES, (charTypeCounts.get(NEUTRAL_ISOLATE_TYPES) || 0) + 1);\n        }\n\n        // Explicit Embeddings: 3.3.2 X2 - X3\n        if (charType & FORMATTING_TYPES) { //prefilter all formatters\n          if (charType & (TYPE_RLE | TYPE_LRE)) {\n            embedLevels[i$2] = stackTop._level; // 5.2\n            var level = (charType === TYPE_RLE ? nextOdd : nextEven)(stackTop._level);\n            if (level <= MAX_DEPTH && !overflowIsolateCount && !overflowEmbeddingCount) {\n              statusStack.push({\n                _level: level,\n                _override: 0,\n                _isolate: 0\n              });\n            } else if (!overflowIsolateCount) {\n              overflowEmbeddingCount++;\n            }\n          }\n\n          // Explicit Overrides: 3.3.2 X4 - X5\n          else if (charType & (TYPE_RLO | TYPE_LRO)) {\n            embedLevels[i$2] = stackTop._level; // 5.2\n            var level$1 = (charType === TYPE_RLO ? nextOdd : nextEven)(stackTop._level);\n            if (level$1 <= MAX_DEPTH && !overflowIsolateCount && !overflowEmbeddingCount) {\n              statusStack.push({\n                _level: level$1,\n                _override: (charType & TYPE_RLO) ? TYPE_R : TYPE_L,\n                _isolate: 0\n              });\n            } else if (!overflowIsolateCount) {\n              overflowEmbeddingCount++;\n            }\n          }\n\n          // Isolates: 3.3.2 X5a - X5c\n          else if (charType & ISOLATE_INIT_TYPES) {\n            // X5c - FSI becomes either RLI or LRI\n            if (charType & TYPE_FSI) {\n              charType = determineAutoEmbedLevel(i$2 + 1, true) === 1 ? TYPE_RLI : TYPE_LRI;\n            }\n\n            embedLevels[i$2] = stackTop._level;\n            if (stackTop._override) {\n              changeCharType(i$2, stackTop._override);\n            }\n            var level$2 = (charType === TYPE_RLI ? nextOdd : nextEven)(stackTop._level);\n            if (level$2 <= MAX_DEPTH && overflowIsolateCount === 0 && overflowEmbeddingCount === 0) {\n              validIsolateCount++;\n              statusStack.push({\n                _level: level$2,\n                _override: 0,\n                _isolate: 1,\n                _isolInitIndex: i$2\n              });\n            } else {\n              overflowIsolateCount++;\n            }\n          }\n\n          // Terminating Isolates: 3.3.2 X6a\n          else if (charType & TYPE_PDI) {\n            if (overflowIsolateCount > 0) {\n              overflowIsolateCount--;\n            } else if (validIsolateCount > 0) {\n              overflowEmbeddingCount = 0;\n              while (!statusStack[statusStack.length - 1]._isolate) {\n                statusStack.pop();\n              }\n              // Add to isolation pairs bidirectional mapping:\n              var isolInitIndex = statusStack[statusStack.length - 1]._isolInitIndex;\n              if (isolInitIndex != null) {\n                isolationPairs.set(isolInitIndex, i$2);\n                isolationPairs.set(i$2, isolInitIndex);\n              }\n              statusStack.pop();\n              validIsolateCount--;\n            }\n            stackTop = statusStack[statusStack.length - 1];\n            embedLevels[i$2] = stackTop._level;\n            if (stackTop._override) {\n              changeCharType(i$2, stackTop._override);\n            }\n          }\n\n\n          // Terminating Embeddings and Overrides: 3.3.2 X7\n          else if (charType & TYPE_PDF) {\n            if (overflowIsolateCount === 0) {\n              if (overflowEmbeddingCount > 0) {\n                overflowEmbeddingCount--;\n              } else if (!stackTop._isolate && statusStack.length > 1) {\n                statusStack.pop();\n                stackTop = statusStack[statusStack.length - 1];\n              }\n            }\n            embedLevels[i$2] = stackTop._level; // 5.2\n          }\n\n          // End of Paragraph: 3.3.2 X8\n          else if (charType & TYPE_B) {\n            embedLevels[i$2] = paragraph.level;\n          }\n        }\n\n        // Non-formatting characters: 3.3.2 X6\n        else {\n          embedLevels[i$2] = stackTop._level;\n          // NOTE: This exclusion of BN seems to go against what section 5.2 says, but is required for test passage\n          if (stackTop._override && charType !== TYPE_BN) {\n            changeCharType(i$2, stackTop._override);\n          }\n        }\n      }\n\n      // === 3.3.3 Preparations for Implicit Processing ===\n\n      // Remove all RLE, LRE, RLO, LRO, PDF, and BN characters: 3.3.3 X9\n      // Note: Due to section 5.2, we won't remove them, but we'll use the BN_LIKE_TYPES bitset to\n      // easily ignore them all from here on out.\n\n      // 3.3.3 X10\n      // Compute the set of isolating run sequences as specified by BD13\n      var levelRuns = [];\n      var currentRun = null;\n      for (var i$3 = paragraph.start; i$3 <= paragraph.end; i$3++) {\n        var charType$1 = charTypes[i$3];\n        if (!(charType$1 & BN_LIKE_TYPES)) {\n          var lvl = embedLevels[i$3];\n          var isIsolInit = charType$1 & ISOLATE_INIT_TYPES;\n          var isPDI = charType$1 === TYPE_PDI;\n          if (currentRun && lvl === currentRun._level) {\n            currentRun._end = i$3;\n            currentRun._endsWithIsolInit = isIsolInit;\n          } else {\n            levelRuns.push(currentRun = {\n              _start: i$3,\n              _end: i$3,\n              _level: lvl,\n              _startsWithPDI: isPDI,\n              _endsWithIsolInit: isIsolInit\n            });\n          }\n        }\n      }\n      var isolatingRunSeqs = []; // [{seqIndices: [], sosType: L|R, eosType: L|R}]\n      for (var runIdx = 0; runIdx < levelRuns.length; runIdx++) {\n        var run = levelRuns[runIdx];\n        if (!run._startsWithPDI || (run._startsWithPDI && !isolationPairs.has(run._start))) {\n          var seqRuns = [currentRun = run];\n          for (var pdiIndex = (void 0); currentRun && currentRun._endsWithIsolInit && (pdiIndex = isolationPairs.get(currentRun._end)) != null;) {\n            for (var i$4 = runIdx + 1; i$4 < levelRuns.length; i$4++) {\n              if (levelRuns[i$4]._start === pdiIndex) {\n                seqRuns.push(currentRun = levelRuns[i$4]);\n                break\n              }\n            }\n          }\n          // build flat list of indices across all runs:\n          var seqIndices = [];\n          for (var i$5 = 0; i$5 < seqRuns.length; i$5++) {\n            var run$1 = seqRuns[i$5];\n            for (var j = run$1._start; j <= run$1._end; j++) {\n              seqIndices.push(j);\n            }\n          }\n          // determine the sos/eos types:\n          var firstLevel = embedLevels[seqIndices[0]];\n          var prevLevel = paragraph.level;\n          for (var i$6 = seqIndices[0] - 1; i$6 >= 0; i$6--) {\n            if (!(charTypes[i$6] & BN_LIKE_TYPES)) { //5.2\n              prevLevel = embedLevels[i$6];\n              break\n            }\n          }\n          var lastIndex = seqIndices[seqIndices.length - 1];\n          var lastLevel = embedLevels[lastIndex];\n          var nextLevel = paragraph.level;\n          if (!(charTypes[lastIndex] & ISOLATE_INIT_TYPES)) {\n            for (var i$7 = lastIndex + 1; i$7 <= paragraph.end; i$7++) {\n              if (!(charTypes[i$7] & BN_LIKE_TYPES)) { //5.2\n                nextLevel = embedLevels[i$7];\n                break\n              }\n            }\n          }\n          isolatingRunSeqs.push({\n            _seqIndices: seqIndices,\n            _sosType: Math.max(prevLevel, firstLevel) % 2 ? TYPE_R : TYPE_L,\n            _eosType: Math.max(nextLevel, lastLevel) % 2 ? TYPE_R : TYPE_L\n          });\n        }\n      }\n\n      // The next steps are done per isolating run sequence\n      for (var seqIdx = 0; seqIdx < isolatingRunSeqs.length; seqIdx++) {\n        var ref = isolatingRunSeqs[seqIdx];\n        var seqIndices$1 = ref._seqIndices;\n        var sosType = ref._sosType;\n        var eosType = ref._eosType;\n        /**\n         * All the level runs in an isolating run sequence have the same embedding level.\n         * \n         * DO NOT change any `embedLevels[i]` within the current scope.\n         */\n        var embedDirection = ((embedLevels[seqIndices$1[0]]) & 1) ? TYPE_R : TYPE_L;\n\n        // === 3.3.4 Resolving Weak Types ===\n\n        // W1 + 5.2. Search backward from each NSM to the first character in the isolating run sequence whose\n        // bidirectional type is not BN, and set the NSM to ON if it is an isolate initiator or PDI, and to its\n        // type otherwise. If the NSM is the first non-BN character, change the NSM to the type of sos.\n        if (charTypeCounts.get(TYPE_NSM)) {\n          for (var si = 0; si < seqIndices$1.length; si++) {\n            var i$8 = seqIndices$1[si];\n            if (charTypes[i$8] & TYPE_NSM) {\n              var prevType = sosType;\n              for (var sj = si - 1; sj >= 0; sj--) {\n                if (!(charTypes[seqIndices$1[sj]] & BN_LIKE_TYPES)) { //5.2 scan back to first non-BN\n                  prevType = charTypes[seqIndices$1[sj]];\n                  break\n                }\n              }\n              changeCharType(i$8, (prevType & (ISOLATE_INIT_TYPES | TYPE_PDI)) ? TYPE_ON : prevType);\n            }\n          }\n        }\n\n        // W2. Search backward from each instance of a European number until the first strong type (R, L, AL, or sos)\n        // is found. If an AL is found, change the type of the European number to Arabic number.\n        if (charTypeCounts.get(TYPE_EN)) {\n          for (var si$1 = 0; si$1 < seqIndices$1.length; si$1++) {\n            var i$9 = seqIndices$1[si$1];\n            if (charTypes[i$9] & TYPE_EN) {\n              for (var sj$1 = si$1 - 1; sj$1 >= -1; sj$1--) {\n                var prevCharType = sj$1 === -1 ? sosType : charTypes[seqIndices$1[sj$1]];\n                if (prevCharType & STRONG_TYPES) {\n                  if (prevCharType === TYPE_AL) {\n                    changeCharType(i$9, TYPE_AN);\n                  }\n                  break\n                }\n              }\n            }\n          }\n        }\n\n        // W3. Change all ALs to R\n        if (charTypeCounts.get(TYPE_AL)) {\n          for (var si$2 = 0; si$2 < seqIndices$1.length; si$2++) {\n            var i$10 = seqIndices$1[si$2];\n            if (charTypes[i$10] & TYPE_AL) {\n              changeCharType(i$10, TYPE_R);\n            }\n          }\n        }\n\n        // W4. A single European separator between two European numbers changes to a European number. A single common\n        // separator between two numbers of the same type changes to that type.\n        if (charTypeCounts.get(TYPE_ES) || charTypeCounts.get(TYPE_CS)) {\n          for (var si$3 = 1; si$3 < seqIndices$1.length - 1; si$3++) {\n            var i$11 = seqIndices$1[si$3];\n            if (charTypes[i$11] & (TYPE_ES | TYPE_CS)) {\n              var prevType$1 = 0, nextType = 0;\n              for (var sj$2 = si$3 - 1; sj$2 >= 0; sj$2--) {\n                prevType$1 = charTypes[seqIndices$1[sj$2]];\n                if (!(prevType$1 & BN_LIKE_TYPES)) { //5.2\n                  break\n                }\n              }\n              for (var sj$3 = si$3 + 1; sj$3 < seqIndices$1.length; sj$3++) {\n                nextType = charTypes[seqIndices$1[sj$3]];\n                if (!(nextType & BN_LIKE_TYPES)) { //5.2\n                  break\n                }\n              }\n              if (prevType$1 === nextType && (charTypes[i$11] === TYPE_ES ? prevType$1 === TYPE_EN : (prevType$1 & (TYPE_EN | TYPE_AN)))) {\n                changeCharType(i$11, prevType$1);\n              }\n            }\n          }\n        }\n\n        // W5. A sequence of European terminators adjacent to European numbers changes to all European numbers.\n        if (charTypeCounts.get(TYPE_EN)) {\n          for (var si$4 = 0; si$4 < seqIndices$1.length; si$4++) {\n            var i$12 = seqIndices$1[si$4];\n            if (charTypes[i$12] & TYPE_EN) {\n              for (var sj$4 = si$4 - 1; sj$4 >= 0 && (charTypes[seqIndices$1[sj$4]] & (TYPE_ET | BN_LIKE_TYPES)); sj$4--) {\n                changeCharType(seqIndices$1[sj$4], TYPE_EN);\n              }\n              for (si$4++; si$4 < seqIndices$1.length && (charTypes[seqIndices$1[si$4]] & (TYPE_ET | BN_LIKE_TYPES | TYPE_EN)); si$4++) {\n                if (charTypes[seqIndices$1[si$4]] !== TYPE_EN) {\n                  changeCharType(seqIndices$1[si$4], TYPE_EN);\n                }\n              }\n            }\n          }\n        }\n\n        // W6. Otherwise, separators and terminators change to Other Neutral.\n        if (charTypeCounts.get(TYPE_ET) || charTypeCounts.get(TYPE_ES) || charTypeCounts.get(TYPE_CS)) {\n          for (var si$5 = 0; si$5 < seqIndices$1.length; si$5++) {\n            var i$13 = seqIndices$1[si$5];\n            if (charTypes[i$13] & (TYPE_ET | TYPE_ES | TYPE_CS)) {\n              changeCharType(i$13, TYPE_ON);\n              // 5.2 transform adjacent BNs too:\n              for (var sj$5 = si$5 - 1; sj$5 >= 0 && (charTypes[seqIndices$1[sj$5]] & BN_LIKE_TYPES); sj$5--) {\n                changeCharType(seqIndices$1[sj$5], TYPE_ON);\n              }\n              for (var sj$6 = si$5 + 1; sj$6 < seqIndices$1.length && (charTypes[seqIndices$1[sj$6]] & BN_LIKE_TYPES); sj$6++) {\n                changeCharType(seqIndices$1[sj$6], TYPE_ON);\n              }\n            }\n          }\n        }\n\n        // W7. Search backward from each instance of a European number until the first strong type (R, L, or sos)\n        // is found. If an L is found, then change the type of the European number to L.\n        // NOTE: implemented in single forward pass for efficiency\n        if (charTypeCounts.get(TYPE_EN)) {\n          for (var si$6 = 0, prevStrongType = sosType; si$6 < seqIndices$1.length; si$6++) {\n            var i$14 = seqIndices$1[si$6];\n            var type = charTypes[i$14];\n            if (type & TYPE_EN) {\n              if (prevStrongType === TYPE_L) {\n                changeCharType(i$14, TYPE_L);\n              }\n            } else if (type & STRONG_TYPES) {\n              prevStrongType = type;\n            }\n          }\n        }\n\n        // === 3.3.5 Resolving Neutral and Isolate Formatting Types ===\n\n        if (charTypeCounts.get(NEUTRAL_ISOLATE_TYPES)) {\n          // N0. Process bracket pairs in an isolating run sequence sequentially in the logical order of the text\n          // positions of the opening paired brackets using the logic given below. Within this scope, bidirectional\n          // types EN and AN are treated as R.\n          var R_TYPES_FOR_N_STEPS = (TYPE_R | TYPE_EN | TYPE_AN);\n          var STRONG_TYPES_FOR_N_STEPS = R_TYPES_FOR_N_STEPS | TYPE_L;\n\n          // * Identify the bracket pairs in the current isolating run sequence according to BD16.\n          var bracketPairs = [];\n          {\n            var openerStack = [];\n            for (var si$7 = 0; si$7 < seqIndices$1.length; si$7++) {\n              // NOTE: for any potential bracket character we also test that it still carries a NI\n              // type, as that may have been changed earlier. This doesn't seem to be explicitly\n              // called out in the spec, but is required for passage of certain tests.\n              if (charTypes[seqIndices$1[si$7]] & NEUTRAL_ISOLATE_TYPES) {\n                var char = string[seqIndices$1[si$7]];\n                var oppositeBracket = (void 0);\n                // Opening bracket\n                if (openingToClosingBracket(char) !== null) {\n                  if (openerStack.length < 63) {\n                    openerStack.push({ char: char, seqIndex: si$7 });\n                  } else {\n                    break\n                  }\n                }\n                // Closing bracket\n                else if ((oppositeBracket = closingToOpeningBracket(char)) !== null) {\n                  for (var stackIdx = openerStack.length - 1; stackIdx >= 0; stackIdx--) {\n                    var stackChar = openerStack[stackIdx].char;\n                    if (stackChar === oppositeBracket ||\n                      stackChar === closingToOpeningBracket(getCanonicalBracket(char)) ||\n                      openingToClosingBracket(getCanonicalBracket(stackChar)) === char\n                    ) {\n                      bracketPairs.push([openerStack[stackIdx].seqIndex, si$7]);\n                      openerStack.length = stackIdx; //pop the matching bracket and all following\n                      break\n                    }\n                  }\n                }\n              }\n            }\n            bracketPairs.sort(function (a, b) { return a[0] - b[0]; });\n          }\n          // * For each bracket-pair element in the list of pairs of text positions\n          for (var pairIdx = 0; pairIdx < bracketPairs.length; pairIdx++) {\n            var ref$1 = bracketPairs[pairIdx];\n            var openSeqIdx = ref$1[0];\n            var closeSeqIdx = ref$1[1];\n            // a. Inspect the bidirectional types of the characters enclosed within the bracket pair.\n            // b. If any strong type (either L or R) matching the embedding direction is found, set the type for both\n            // brackets in the pair to match the embedding direction.\n            var foundStrongType = false;\n            var useStrongType = 0;\n            for (var si$8 = openSeqIdx + 1; si$8 < closeSeqIdx; si$8++) {\n              var i$15 = seqIndices$1[si$8];\n              if (charTypes[i$15] & STRONG_TYPES_FOR_N_STEPS) {\n                foundStrongType = true;\n                var lr = (charTypes[i$15] & R_TYPES_FOR_N_STEPS) ? TYPE_R : TYPE_L;\n                if (lr === embedDirection) {\n                  useStrongType = lr;\n                  break\n                }\n              }\n            }\n            // c. Otherwise, if there is a strong type it must be opposite the embedding direction. Therefore, test\n            // for an established context with a preceding strong type by checking backwards before the opening paired\n            // bracket until the first strong type (L, R, or sos) is found.\n            //    1. If the preceding strong type is also opposite the embedding direction, context is established, so\n            //    set the type for both brackets in the pair to that direction.\n            //    2. Otherwise set the type for both brackets in the pair to the embedding direction.\n            if (foundStrongType && !useStrongType) {\n              useStrongType = sosType;\n              for (var si$9 = openSeqIdx - 1; si$9 >= 0; si$9--) {\n                var i$16 = seqIndices$1[si$9];\n                if (charTypes[i$16] & STRONG_TYPES_FOR_N_STEPS) {\n                  var lr$1 = (charTypes[i$16] & R_TYPES_FOR_N_STEPS) ? TYPE_R : TYPE_L;\n                  if (lr$1 !== embedDirection) {\n                    useStrongType = lr$1;\n                  } else {\n                    useStrongType = embedDirection;\n                  }\n                  break\n                }\n              }\n            }\n            if (useStrongType) {\n              charTypes[seqIndices$1[openSeqIdx]] = charTypes[seqIndices$1[closeSeqIdx]] = useStrongType;\n              // * Any number of characters that had original bidirectional character type NSM prior to the application\n              // of W1 that immediately follow a paired bracket which changed to L or R under N0 should change to match\n              // the type of their preceding bracket.\n              if (useStrongType !== embedDirection) {\n                for (var si$10 = openSeqIdx + 1; si$10 < seqIndices$1.length; si$10++) {\n                  if (!(charTypes[seqIndices$1[si$10]] & BN_LIKE_TYPES)) {\n                    if (getBidiCharType(string[seqIndices$1[si$10]]) & TYPE_NSM) {\n                      charTypes[seqIndices$1[si$10]] = useStrongType;\n                    }\n                    break\n                  }\n                }\n              }\n              if (useStrongType !== embedDirection) {\n                for (var si$11 = closeSeqIdx + 1; si$11 < seqIndices$1.length; si$11++) {\n                  if (!(charTypes[seqIndices$1[si$11]] & BN_LIKE_TYPES)) {\n                    if (getBidiCharType(string[seqIndices$1[si$11]]) & TYPE_NSM) {\n                      charTypes[seqIndices$1[si$11]] = useStrongType;\n                    }\n                    break\n                  }\n                }\n              }\n            }\n          }\n\n          // N1. A sequence of NIs takes the direction of the surrounding strong text if the text on both sides has the\n          // same direction.\n          // N2. Any remaining NIs take the embedding direction.\n          for (var si$12 = 0; si$12 < seqIndices$1.length; si$12++) {\n            if (charTypes[seqIndices$1[si$12]] & NEUTRAL_ISOLATE_TYPES) {\n              var niRunStart = si$12, niRunEnd = si$12;\n              var prevType$2 = sosType; //si === 0 ? sosType : (charTypes[seqIndices[si - 1]] & R_TYPES_FOR_N_STEPS) ? TYPE_R : TYPE_L\n              for (var si2 = si$12 - 1; si2 >= 0; si2--) {\n                if (charTypes[seqIndices$1[si2]] & BN_LIKE_TYPES) {\n                  niRunStart = si2; //5.2 treat BNs adjacent to NIs as NIs\n                } else {\n                  prevType$2 = (charTypes[seqIndices$1[si2]] & R_TYPES_FOR_N_STEPS) ? TYPE_R : TYPE_L;\n                  break\n                }\n              }\n              var nextType$1 = eosType;\n              for (var si2$1 = si$12 + 1; si2$1 < seqIndices$1.length; si2$1++) {\n                if (charTypes[seqIndices$1[si2$1]] & (NEUTRAL_ISOLATE_TYPES | BN_LIKE_TYPES)) {\n                  niRunEnd = si2$1;\n                } else {\n                  nextType$1 = (charTypes[seqIndices$1[si2$1]] & R_TYPES_FOR_N_STEPS) ? TYPE_R : TYPE_L;\n                  break\n                }\n              }\n              for (var sj$7 = niRunStart; sj$7 <= niRunEnd; sj$7++) {\n                charTypes[seqIndices$1[sj$7]] = prevType$2 === nextType$1 ? prevType$2 : embedDirection;\n              }\n              si$12 = niRunEnd;\n            }\n          }\n        }\n      }\n\n      // === 3.3.6 Resolving Implicit Levels ===\n\n      for (var i$17 = paragraph.start; i$17 <= paragraph.end; i$17++) {\n        var level$3 = embedLevels[i$17];\n        var type$1 = charTypes[i$17];\n        // I2. For all characters with an odd (right-to-left) embedding level, those of type L, EN or AN go up one level.\n        if (level$3 & 1) {\n          if (type$1 & (TYPE_L | TYPE_EN | TYPE_AN)) {\n            embedLevels[i$17]++;\n          }\n        }\n          // I1. For all characters with an even (left-to-right) embedding level, those of type R go up one level\n        // and those of type AN or EN go up two levels.\n        else {\n          if (type$1 & TYPE_R) {\n            embedLevels[i$17]++;\n          } else if (type$1 & (TYPE_AN | TYPE_EN)) {\n            embedLevels[i$17] += 2;\n          }\n        }\n\n        // 5.2: Resolve any LRE, RLE, LRO, RLO, PDF, or BN to the level of the preceding character if there is one,\n        // and otherwise to the base level.\n        if (type$1 & BN_LIKE_TYPES) {\n          embedLevels[i$17] = i$17 === 0 ? paragraph.level : embedLevels[i$17 - 1];\n        }\n\n        // 3.4 L1.1-4: Reset the embedding level of segment/paragraph separators, and any sequence of whitespace or\n        // isolate formatting characters preceding them or the end of the paragraph, to the paragraph level.\n        // NOTE: this will also need to be applied to each individual line ending after line wrapping occurs.\n        if (i$17 === paragraph.end || getBidiCharType(string[i$17]) & (TYPE_S | TYPE_B)) {\n          for (var j$1 = i$17; j$1 >= 0 && (getBidiCharType(string[j$1]) & TRAILING_TYPES); j$1--) {\n            embedLevels[j$1] = paragraph.level;\n          }\n        }\n      }\n    }\n\n    // DONE! The resolved levels can then be used, after line wrapping, to flip runs of characters\n    // according to section 3.4 Reordering Resolved Levels\n    return {\n      levels: embedLevels,\n      paragraphs: paragraphs\n    }\n\n    function determineAutoEmbedLevel (start, isFSI) {\n      // 3.3.1 P2 - P3\n      for (var i = start; i < string.length; i++) {\n        var charType = charTypes[i];\n        if (charType & (TYPE_R | TYPE_AL)) {\n          return 1\n        }\n        if ((charType & (TYPE_B | TYPE_L)) || (isFSI && charType === TYPE_PDI)) {\n          return 0\n        }\n        if (charType & ISOLATE_INIT_TYPES) {\n          var pdi = indexOfMatchingPDI(i);\n          i = pdi === -1 ? string.length : pdi;\n        }\n      }\n      return 0\n    }\n\n    function indexOfMatchingPDI (isolateStart) {\n      // 3.1.2 BD9\n      var isolationLevel = 1;\n      for (var i = isolateStart + 1; i < string.length; i++) {\n        var charType = charTypes[i];\n        if (charType & TYPE_B) {\n          break\n        }\n        if (charType & TYPE_PDI) {\n          if (--isolationLevel === 0) {\n            return i\n          }\n        } else if (charType & ISOLATE_INIT_TYPES) {\n          isolationLevel++;\n        }\n      }\n      return -1\n    }\n  }\n\n  // Bidi mirrored chars data, auto generated\n  var data = \"14>1,j>2,t>2,u>2,1a>g,2v3>1,1>1,1ge>1,1wd>1,b>1,1j>1,f>1,ai>3,-2>3,+1,8>1k0,-1jq>1y7,-1y6>1hf,-1he>1h6,-1h5>1ha,-1h8>1qi,-1pu>1,6>3u,-3s>7,6>1,1>1,f>1,1>1,+2,3>1,1>1,+13,4>1,1>1,6>1eo,-1ee>1,3>1mg,-1me>1mk,-1mj>1mi,-1mg>1mi,-1md>1,1>1,+2,1>10k,-103>1,1>1,4>1,5>1,1>1,+10,3>1,1>8,-7>8,+1,-6>7,+1,a>1,1>1,u>1,u6>1,1>1,+5,26>1,1>1,2>1,2>2,8>1,7>1,4>1,1>1,+5,b8>1,1>1,+3,1>3,-2>1,2>1,1>1,+2,c>1,3>1,1>1,+2,h>1,3>1,a>1,1>1,2>1,3>1,1>1,d>1,f>1,3>1,1a>1,1>1,6>1,7>1,13>1,k>1,1>1,+19,4>1,1>1,+2,2>1,1>1,+18,m>1,a>1,1>1,lk>1,1>1,4>1,2>1,f>1,3>1,1>1,+3,db>1,1>1,+3,3>1,1>1,+2,14qm>1,1>1,+1,6>1,4j>1,j>2,t>2,u>2,2>1,+1\";\n\n  var mirrorMap;\n\n  function parse () {\n    if (!mirrorMap) {\n      //const start = performance.now()\n      var ref = parseCharacterMap(data, true);\n      var map = ref.map;\n      var reverseMap = ref.reverseMap;\n      // Combine both maps into one\n      reverseMap.forEach(function (value, key) {\n        map.set(key, value);\n      });\n      mirrorMap = map;\n      //console.log(`mirrored chars parsed in ${performance.now() - start}ms`)\n    }\n  }\n\n  function getMirroredCharacter (char) {\n    parse();\n    return mirrorMap.get(char) || null\n  }\n\n  /**\n   * Given a string and its resolved embedding levels, build a map of indices to replacement chars\n   * for any characters in right-to-left segments that have defined mirrored characters.\n   * @param string\n   * @param embeddingLevels\n   * @param [start]\n   * @param [end]\n   * @return {Map<number, string>}\n   */\n  function getMirroredCharactersMap(string, embeddingLevels, start, end) {\n    var strLen = string.length;\n    start = Math.max(0, start == null ? 0 : +start);\n    end = Math.min(strLen - 1, end == null ? strLen - 1 : +end);\n\n    var map = new Map();\n    for (var i = start; i <= end; i++) {\n      if (embeddingLevels[i] & 1) { //only odd (rtl) levels\n        var mirror = getMirroredCharacter(string[i]);\n        if (mirror !== null) {\n          map.set(i, mirror);\n        }\n      }\n    }\n    return map\n  }\n\n  /**\n   * Given a start and end denoting a single line within a string, and a set of precalculated\n   * bidi embedding levels, produce a list of segments whose ordering should be flipped, in sequence.\n   * @param {string} string - the full input string\n   * @param {GetEmbeddingLevelsResult} embeddingLevelsResult - the result object from getEmbeddingLevels\n   * @param {number} [start] - first character in a subset of the full string\n   * @param {number} [end] - last character in a subset of the full string\n   * @return {number[][]} - the list of start/end segments that should be flipped, in order.\n   */\n  function getReorderSegments(string, embeddingLevelsResult, start, end) {\n    var strLen = string.length;\n    start = Math.max(0, start == null ? 0 : +start);\n    end = Math.min(strLen - 1, end == null ? strLen - 1 : +end);\n\n    var segments = [];\n    embeddingLevelsResult.paragraphs.forEach(function (paragraph) {\n      var lineStart = Math.max(start, paragraph.start);\n      var lineEnd = Math.min(end, paragraph.end);\n      if (lineStart < lineEnd) {\n        // Local slice for mutation\n        var lineLevels = embeddingLevelsResult.levels.slice(lineStart, lineEnd + 1);\n\n        // 3.4 L1.4: Reset any sequence of whitespace characters and/or isolate formatting characters at the\n        // end of the line to the paragraph level.\n        for (var i = lineEnd; i >= lineStart && (getBidiCharType(string[i]) & TRAILING_TYPES); i--) {\n          lineLevels[i] = paragraph.level;\n        }\n\n        // L2. From the highest level found in the text to the lowest odd level on each line, including intermediate levels\n        // not actually present in the text, reverse any contiguous sequence of characters that are at that level or higher.\n        var maxLevel = paragraph.level;\n        var minOddLevel = Infinity;\n        for (var i$1 = 0; i$1 < lineLevels.length; i$1++) {\n          var level = lineLevels[i$1];\n          if (level > maxLevel) { maxLevel = level; }\n          if (level < minOddLevel) { minOddLevel = level | 1; }\n        }\n        for (var lvl = maxLevel; lvl >= minOddLevel; lvl--) {\n          for (var i$2 = 0; i$2 < lineLevels.length; i$2++) {\n            if (lineLevels[i$2] >= lvl) {\n              var segStart = i$2;\n              while (i$2 + 1 < lineLevels.length && lineLevels[i$2 + 1] >= lvl) {\n                i$2++;\n              }\n              if (i$2 > segStart) {\n                segments.push([segStart + lineStart, i$2 + lineStart]);\n              }\n            }\n          }\n        }\n      }\n    });\n    return segments\n  }\n\n  /**\n   * @param {string} string\n   * @param {GetEmbeddingLevelsResult} embedLevelsResult\n   * @param {number} [start]\n   * @param {number} [end]\n   * @return {string} the new string with bidi segments reordered\n   */\n  function getReorderedString(string, embedLevelsResult, start, end) {\n    var indices = getReorderedIndices(string, embedLevelsResult, start, end);\n    var chars = [].concat( string );\n    indices.forEach(function (charIndex, i) {\n      chars[i] = (\n        (embedLevelsResult.levels[charIndex] & 1) ? getMirroredCharacter(string[charIndex]) : null\n      ) || string[charIndex];\n    });\n    return chars.join('')\n  }\n\n  /**\n   * @param {string} string\n   * @param {GetEmbeddingLevelsResult} embedLevelsResult\n   * @param {number} [start]\n   * @param {number} [end]\n   * @return {number[]} an array with character indices in their new bidi order\n   */\n  function getReorderedIndices(string, embedLevelsResult, start, end) {\n    var segments = getReorderSegments(string, embedLevelsResult, start, end);\n    // Fill an array with indices\n    var indices = [];\n    for (var i = 0; i < string.length; i++) {\n      indices[i] = i;\n    }\n    // Reverse each segment in order\n    segments.forEach(function (ref) {\n      var start = ref[0];\n      var end = ref[1];\n\n      var slice = indices.slice(start, end + 1);\n      for (var i = slice.length; i--;) {\n        indices[end - i] = slice[i];\n      }\n    });\n    return indices\n  }\n\n  exports.closingToOpeningBracket = closingToOpeningBracket;\n  exports.getBidiCharType = getBidiCharType;\n  exports.getBidiCharTypeName = getBidiCharTypeName;\n  exports.getCanonicalBracket = getCanonicalBracket;\n  exports.getEmbeddingLevels = getEmbeddingLevels;\n  exports.getMirroredCharacter = getMirroredCharacter;\n  exports.getMirroredCharactersMap = getMirroredCharactersMap;\n  exports.getReorderSegments = getReorderSegments;\n  exports.getReorderedIndices = getReorderedIndices;\n  exports.getReorderedString = getReorderedString;\n  exports.openingToClosingBracket = openingToClosingBracket;\n\n  Object.defineProperty(exports, '__esModule', { value: true });\n\n  return exports;\n\n}({}));\nreturn bidi}\n\nexport default bidiFactory;\n"],"names":["bidiFactory","bidi","exports","DATA","TYPES","TYPES_TO_NAMES","type","i","ISOLATE_INIT_TYPES","STRONG_TYPES","NEUTRAL_ISOLATE_TYPES","BN_LIKE_TYPES","TRAILING_TYPES","map","parseData","loop","lastCode","range","ref","skip","step","getBidiCharType","char","getBidiCharTypeName","data$1","parseCharacterMap","encodedString","includeReverse","radix","reverseMap","prevPair","visit","entry","a","b","openToClose","closeToOpen","canonical","parse$1","openingToClosingBracket","closingToOpeningBracket","getCanonicalBracket","TYPE_L","TYPE_R","TYPE_EN","TYPE_ES","TYPE_ET","TYPE_AN","TYPE_CS","TYPE_B","TYPE_S","TYPE_ON","TYPE_BN","TYPE_NSM","TYPE_AL","TYPE_LRO","TYPE_RLO","TYPE_LRE","TYPE_RLE","TYPE_PDF","TYPE_LRI","TYPE_RLI","TYPE_FSI","TYPE_PDI","getEmbeddingLevels","string","baseDirection","MAX_DEPTH","charTypes","charTypeCounts","changeCharType","oldType","embedLevels","isolationPairs","paragraphs","paragraph","i$1","determineAutoEmbedLevel","FORMATTING_TYPES","nextEven","n","nextOdd","paraIdx","statusStack","stackTop","overflowIsolateCount","overflowEmbeddingCount","validIsolateCount","i$2","charType","level","level$1","level$2","isolInitIndex","levelRuns","currentRun","i$3","charType$1","lvl","isIsolInit","isPDI","isolatingRunSeqs","runIdx","run","seqRuns","pdiIndex","i$4","seqIndices","i$5","run$1","j","firstLevel","prevLevel","i$6","lastIndex","lastLevel","nextLevel","i$7","seqIdx","seqIndices$1","sosType","eosType","embedDirection","si","i$8","prevType","sj","si$1","i$9","sj$1","prevCharType","si$2","i$10","si$3","i$11","prevType$1","nextType","sj$2","sj$3","si$4","i$12","sj$4","si$5","i$13","sj$5","sj$6","si$6","prevStrongType","i$14","R_TYPES_FOR_N_STEPS","STRONG_TYPES_FOR_N_STEPS","bracketPairs","openerStack","si$7","oppositeBracket","stackIdx","stackChar","pairIdx","ref$1","openSeqIdx","closeSeqIdx","foundStrongType","useStrongType","si$8","i$15","lr","si$9","i$16","lr$1","si$10","si$11","si$12","niRunStart","niRunEnd","prevType$2","si2","nextType$1","si2$1","sj$7","i$17","level$3","type$1","j$1","start","isFSI","pdi","indexOfMatchingPDI","isolateStart","isolationLevel","data","mirrorMap","parse","value","key","getMirroredCharacter","getMirroredCharactersMap","embeddingLevels","end","strLen","mirror","getReorderSegments","embeddingLevelsResult","segments","lineStart","lineEnd","lineLevels","maxLevel","minOddLevel","segStart","getReorderedString","embedLevelsResult","indices","getReorderedIndices","chars","charIndex","slice"],"mappings":"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","x_google_ignoreList":[0]}